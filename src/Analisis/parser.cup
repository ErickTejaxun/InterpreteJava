package Analisis;
import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import AST.*;
import Utilidades.ErrorC;
import AST.Instruccion.*;
import AST.Instruccion.Ciclos.*;
import AST.Expresion.*;
import AST.Entorno.*;
import AST.Expresion.Aritmetica.*;
import AST.Expresion.Relacional.*;
import AST.Expresion.Logica.*;
import AST.Expresion.Arreglo.*;
import AST.Expresion.Casteo.*;
import AST.Expresion.Casteo.Explicito.*;
import AST.Expresion.Metodos.*;


parser code
{:	   	
	public ArrayList<ErrorC> listaErrores = new ArrayList();	
	public ArrayList<Instruccion> ast = new ArrayList<Instruccion>();

	public AST raiz = null;

	/*@Override
	public void syntax_error(Symbol cur_token) 
	{        
		List<Integer> listaIdTokens = expected_token_ids();
		LinkedList<String> listaNombres = new LinkedList<String>();
		for (Integer expected : listaIdTokens) 
		{			
			listaNombres.add(symbl_name_from_id(expected));
		}		
		Utilidades.Singlenton.registrarError(String.valueOf(cur_token.value), 
			String.valueOf(cur_token.value) + ". Se esperaba :"+listaNombres.toString(), ErrorC.TipoError.LEXICO, cur_token.right+1, cur_token.left+1);
		/*listaErrores.add(
					listaErrores.add(new ErrorC(ErrorC.TipoError.SINTACTICO,
								String.valueOf(cur_token.value) + ". Se esperaba :"+listaNombres.toString(),
								cur_token.right+1,
								cur_token.left+1));
                
	}*/


    public void report_error(String message, Object info) 
    {
        int linea = 0;
        int columna = 0;
        java_cup.runtime.Symbol s = null;
        StringBuilder m = new StringBuilder("Error Sintactico");

        if (info instanceof java_cup.runtime.Symbol) 
        {
            s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) 
            {                
                columna = s.left+1;
                if (s.right>= 0)
                {
                    linea = s.right+ 1;
                }                    
            }
        }

        m.append(" Se esperaba: "+message);
        //System.err.println(m.toString());
        //System.out.println("Error");
        //System.out.println("Error linea:"+linea+", col:"+columna);
        LinkedList<String> toks = new LinkedList();

        if(!expected_token_ids().isEmpty())
        {
            Imprimir("No esta vacia "+ expected_token_ids().size());		  
            for(int w=0; w<expected_token_ids().size(); w++)
            { 
                if(expected_token_ids().get(w) !=sym.error)
                {
                    int tok = (int)expected_token_ids().get(w);                        
                    toks.add( symbol_name_from_id(tok) );
                }
            }
        }

        Imprimir(expected_token_ids().size());
      
        for(int w=0; w<expected_token_ids().size(); w++)
        { 
            if(expected_token_ids().get(w)!=sym.error)
            {
                int tok = (int)expected_token_ids().get(w);
                toks.add( symbol_name_from_id(tok) );
            }
        }
        String esperados = "";
        for(String id : toks)
        {
            if(!esperados.equals(""))
            {
                esperados += ", ";
            }
            esperados += id;
            
        }        
        Utilidades.Singlenton.registrarError(s.value.toString(), "Se esperaba .. " +esperados, ErrorC.TipoError.SINTACTICO, linea, columna);		                  
    }	

    public String symbol_name_from_id(int id){
        return sym.terminalNames[id];
    }

	/*public void addError(Symbol s)
	{
		listaErrores.add(new ErrorC("Sintactico",s.rights.right+1,ConvertirObjectToString(s.value)));
	}*/
	public void Imprimir(Object cad)
	{
		System.out.println(cad.toString());
	}	
:}


terminal String tint, tdouble, tchar, tbool, tstring, puntocoma, llavei, llaved, pari, pard, id, corchetei, corcheted, igual, print, println, coma;
terminal String igualigual, desigual, mayor, menor, menorigual, mayorigual, potencia , tvoid, nulo;
terminal String abstracto, caso, cat, clase, defecto, hacer, extiende, final_, graph;
terminal String importar, instanceof_, nuevo, privado, protegido, publico, retorno;
/*Casteos*/
terminal String leerarchivo,estatico, super_, switch_, este, tochar, todouble, toint, str_, try_, escribir;
terminal String mientras, para, romper, continuar ,interrogante, dospuntos, aumento, decremento, punto;
terminal String not, and, or, si, sinosi, sino, tostring, tolower, touper;
terminal String suma, menos, multi, div, xor, printable, modulo;
terminal String cadena;
terminal char caracter;
terminal int entero;
terminal double decimal;
terminal boolean booleano;

non terminal Bloque BLOQUE;
non terminal ArrayList<Nodo> LINST;
non terminal Nodo INST;
non terminal Declaracion DECLARACION;
non terminal Expresion EXP, AUMENTO, DECREMENTO, EXPLICITCAST;
non terminal INICIO;
non terminal Tipo PRIMITIVO;
non terminal Imprimir PRINT;
non terminal ImprimirT PRINTABLE;
non terminal Asignacion ASIG;
non terminal While WHILE;
non terminal DoWhile DOWHILE;
non terminal Break BREAK;
non terminal Continuar CONTINUE;
non terminal If IF, ELSE;
non terminal Ternario TER;
non terminal For FOR;
non terminal Expresion ACTUALIZACION, EXPRETORNO;
non terminal Integer NDIM;
non terminal ArrayList<Expresion> LEXP;
non terminal AsignacionVector ASIGV;
non terminal NodoNario ITEM,LITEM,ARR;
non terminal Tipo TIPO;
non terminal ArrayList<Dec> LDEC;
non terminal Dec DEC;
non terminal ForEach FOREACH;
non terminal Caso CASO, DEFECTO;
non terminal ArrayList<Caso> LCASO;
non terminal Switch SWITCH;
non terminal ArrayList<String> LMODFICADOR;
non terminal String MODIFICADOR;
non terminal Tipo RESULTADO;
non terminal ParametroFormal PARFORMAL;
non terminal ArrayList<ParametroFormal> LPARFORMAL;
non terminal Funcion FUNCION, CABECERAMET;
non terminal ArrayList<Nodo> LFUNCION;
non terminal Retorno RETORNO;
/*
precedence left interrogante, punto;
precedence left or;
precedence left and;
precedence left xor;
precedence left igualigual, desigual;
precedence left menor, mayor, mayorigual, menorigual, instanceof_;
precedence left suma, menos;
precedence left multi, div, modulo;
precedence left not;
precedence left aumento, decremento ;
*/

precedence right interrogante, dospuntos;
precedence left or;
precedence left and;
precedence left xor;
precedence left igualigual, desigual;
precedence left menor, menorigual, mayor, mayorigual, instanceof_;
precedence left suma, menos;
precedence left div, multi, modulo;
precedence left not;
precedence right nuevo;
precedence nonassoc aumento, decremento, not;
precedence nonassoc pard , pari;
precedence nonassoc corcheted , corchetei;
precedence left punto;



start with INICIO;

INICIO ::= LFUNCION:inst {: Imprimir("Correcto"); raiz = new AST(inst);; :}		
		;

LFUNCION::= 
          LFUNCION:l FUNCION:f {:l.add(f); RESULT = l;:}
        | FUNCION:f  {:ArrayList<Nodo> l = new ArrayList<Nodo>(); l.add(f); RESULT = l;:}      
        ; 

BLOQUE::= llavei LINST:l llaved {:RESULT = new Bloque(l,lright,lleft);:}
        | llavei:l  llaved {:RESULT = new Bloque(new ArrayList<Nodo>(),lright,lleft);:}
		;

LINST::= LINST:lista INST:inst {: lista.add(inst); RESULT = lista;:}
	   |INST:inst {: ArrayList<Nodo> l = new ArrayList<Nodo>(); l.add(inst); RESULT = l;:} ;

INST ::= 
	  DECLARACION:inst puntocoma {: RESULT = inst; :}    
    | ASIG:inst  puntocoma {:RESULT = inst;:}      
	| BLOQUE:inst {: RESULT = inst; :}
	| PRINT:inst{: RESULT = inst; :}
    | PRINTABLE:inst{:RESULT = inst;:}    
    | WHILE:inst {:RESULT = inst;:}
    | DOWHILE:inst {:RESULT = inst;:}
    | FOR:inst{:RESULT = inst;:}
    | BREAK:inst {:RESULT = inst;:}
    | CONTINUE:inst {:RESULT = inst;:}
    | IF:inst{:RESULT = inst;:}
    | AUMENTO:inst puntocoma {:RESULT = inst;:}
    | DECREMENTO:inst puntocoma {:RESULT = inst;:}
    | ASIGV:inst puntocoma {:RESULT = inst;:}
    | FOREACH:inst {:RESULT = inst;:}
    | SWITCH:inst {:RESULT = inst;:}
    | RETORNO:inst {:RESULT = inst;:}
	;

/*Casteos Explicitos*/
EXPLICITCAST::= str_:t pari EXP:expresion pard {: RESULT = new StringCast(expresion, tright, tleft);:}
            |  todouble:t pari EXP:expresion pard {: RESULT = new DoubleCast(expresion, tright, tleft);:}
            |  tochar:t pari EXP:expresion pard {: RESULT = new CharCast(expresion, tright, tleft);:} 
            |  toint:t pari EXP:expresion pard {: RESULT = new IntCast(expresion, tright, tleft);:}
;

ACTUALIZACION::= AUMENTO :inst {:RESULT =inst;:}
                |DECREMENTO :inst {:RESULT =inst;:}
;

/*Seleccion
(Expresion cond, ArrayList<Caso> lista, int l, int c)
*/

SWITCH::= switch_:i pari EXP:condicion pard llavei LCASO:lista llaved
            {:
                RESULT = new Switch(condicion, lista, iright, ileft);
            :}
            | switch_:i pari EXP:condicion pard llavei LCASO:lista DEFECTO:defecto llaved 
            {:
                lista.add(defecto);
                RESULT = new Switch(condicion, lista, iright, ileft);
            :}
;

LCASO::= LCASO:l CASO:caso {:l.add(caso); RESULT = l;:}
        |CASO:caso {:ArrayList<Caso> l = new ArrayList<Caso>(); l.add(caso); RESULT = l;:}
;

CASO::= caso:i EXP:condicion dospuntos LINST:linst {:RESULT = new Caso(condicion,new Bloque(linst,linstright,linstleft),iright,ileft);:}
;

DEFECTO::= defecto:i dospuntos LINST:linst {:RESULT = new Caso(null,new Bloque(linst,linstright,linstleft),iright,ileft);:}
;

IF::= si:si pari EXP:condicion pard BLOQUE:bloque {:RESULT = new If(condicion, bloque, siright, sileft);:}
    | si:si pari EXP:condicion pard BLOQUE:bloque sino ELSE:inst2 {: RESULT= new If(condicion,bloque,inst2,siright, sileft);:}
;

ELSE::= IF:inst  {:RESULT = inst;:}
      | BLOQUE:bloque {: RESULT = new If(new Literal(new Tipo(Tipo.TypePrimitive.BOOL), true, bloqueright,bloqueleft),bloque, bloqueright, bloqueleft); :}
;

CONTINUE::= continuar:inst puntocoma {: RESULT = new Continuar(instright, instleft);:}
;

BREAK::= romper:inst puntocoma {: RESULT = new Break(instright, instleft);:}
;

WHILE::= mientras:inst pari EXP:condicion pard BLOQUE:bloque {: RESULT = new While(condicion,bloque,instright, instleft);:}
;

DOWHILE::=  hacer:i BLOQUE:bloque mientras:inst pari EXP:condicion pard puntocoma
        {:
            RESULT = new DoWhile(condicion, bloque, iright, ileft);
        :}
;

/*FOREACH ForEach(Tipo t, String i, Expresion o, int l, int c)*/
FOREACH::= para:para pari TIPO:t id:id dospuntos EXP:origen pard BLOQUE:bloque
        {:RESULT = new ForEach(t,id,origen, bloque, pararight,paraleft);:}
;

FOR::= 
      para:para pari DECLARACION:dec puntocoma EXP:condicion puntocoma ACTUALIZACION:act  pard BLOQUE:bloque{: RESULT = new For(dec,condicion,act,bloque, paraleft,pararight);:}
    | para:para pari ASIG:dec puntocoma EXP:condicion puntocoma ACTUALIZACION:act  pard BLOQUE:bloque{: RESULT = new For(dec,condicion,act,bloque,paraleft,pararight);:}
;

PRINTABLE::= printable:p pari pard puntocoma {:RESULT = new ImprimirT(pright,pleft); :}
;

PRINT::= println:p pari EXP:valor pard puntocoma {:RESULT = new Imprimir(valor, pright,pleft); :}
        | print:p pari EXP:valor pard puntocoma {:RESULT = new Imprimir(valor,false,pright,pleft); :}
;

ASIG::= id:id igual EXP:valor   {: RESULT = new Asignacion(id, valor, idright,idleft);:};

ASIGV::=id:id LEXP:coordenas igual EXP:valor {: RESULT = new AsignacionVector(id, coordenas, valor,  idright,idleft);:}
;

/*Arreglos.
DECLARACION::=  
	    TIPO:t id:id  {: RESULT = new Declaracion(t, id , tright,tleft); :}
	   |TIPO:t id:id  igual EXP:valor  {: RESULT = new Declaracion(t, id, valor, tright,tleft); :}
       
       |TIPO:t id:id NDIM:n {: RESULT = new Declaracion(t, id , n, tright,tleft); :}    
       |TIPO:t id:id NDIM:n igual EXP:valor {: RESULT = new Declaracion(t, id , n, valor, tright,tleft); :}                
       |TIPO:t id:id NDIM:n igual ARR:valor {: RESULT = new Declaracion(t, id , n, new ExpresionArreglo(valor, valorright, valorleft), tright,tleft); :}
	   ;
*/


DECLARACION::= TIPO:t LDEC:lista {: RESULT = new Declaracion(t, lista, tright, tleft); :} ;


LDEC::= LDEC:lista  coma DEC:dec {: lista.add(dec); RESULT = lista;:}
        |DEC:dec {: ArrayList<Dec> lista = new ArrayList<Dec>(); lista.add(dec); RESULT = lista;:}
;

DEC::= 
      id:id {: RESULT = new Dec(id,idright, idleft);:}
    | id:id igual EXP:valor {: RESULT = new Dec(id,valor, idright, idleft);:}
    | id:id NDIM:dim {: RESULT = new Dec(id,dim, idright, idleft);:}
    | id:id NDIM:dim igual EXP:valor {: RESULT = new Dec(id,dim, valor, idright, idleft);:}
    | id:id NDIM:dim igual ARR:valor {: RESULT = new Dec(id,dim, new ExpresionArreglo(valor, valorright, valorleft), idright, idleft);:}
;    



TIPO::= PRIMITIVO:t{:RESULT = t;:}
      | id:id {:RESULT = new Tipo(id,idright, idleft);:}
;


/*Dimensiones*/
NDIM::= NDIM:n corchetei corcheted {:RESULT = n+1;:}
        |corchetei corcheted {: RESULT = 1;:}
;  

/*
EXPRESION::= 
            EXP:exp {:RESULT = exp;:}
          | RETORNO:r {:RESULT = r;:}
;
*/

EXP::= 
         EXP:opi and EXP:opd {: RESULT = new And(opi, opd, opiright,opileft);:}
        |EXP:opi or EXP:opd {: RESULT = new Or(opi, opd, opiright,opileft);:}
        |not EXP:op {: RESULT = new Not(op, opright,opleft);:}        
        |EXP:opi igualigual EXP:opd {:RESULT = new Igual(opi,opd,opiright,opileft);:}
        |EXP:opi desigual EXP:opd {:RESULT = new Desigual(opi,opd,opiright,opileft);:}
        |EXP:opi mayor EXP:opd {:RESULT = new Mayor(opi,opd,opiright,opileft);:}
        |EXP:opi mayorigual EXP:opd {:RESULT = new MayorIgual(opi,opd,opiright,opileft);:}
        |EXP:opi menor EXP:opd {:RESULT = new Menor(opi,opd,opiright,opileft);:}
        |EXP:opi menorigual EXP:opd {:RESULT = new MenorIgual(opi,opd,opiright,opileft);:}        
        |EXP:opi suma EXP:opd {: RESULT = new Suma(opi,opd,opiright,opileft);:}       
        |EXP:opi menos EXP:opd {: RESULT = new Resta(opi,opd,opiright,opileft);:}  
        |EXP:opi xor EXP:opd {: RESULT = new Xor(opi,opd,opiright,opileft);:} 
        |EXP:opi multi EXP:opd {: RESULT = new Multiplicacion(opi,opd,opiright,opileft);:}  
        |EXP:opi div EXP:opd {: RESULT = new Division(opi,opd,opiright,opileft);:}  
        |EXP:opi modulo EXP:opd {: RESULT = new Modulo(opi,opd,opiright,opileft);:}  
        |TER:op {:RESULT = op;:}                
        |menos EXP:op {: RESULT = new Menos(op, opright,opleft);:}              
        |AUMENTO:op {:RESULT = op;:}
        |potencia:pot pari EXP:opi coma EXP:opd pard {:RESULT = new Potencia(opi,opd,potright,potleft);:}
        |EXP:op instanceof_ id:tipo {:RESULT = new InstanceOf(op,tipo, opright, opleft);:}
        |DECREMENTO:op {:RESULT = op;:}
        |EXP:op punto id:t pari pard {:RESULT = new Llamada(op,t, opright,opleft);:}
        |EXP:op punto tostring pari pard {:RESULT = new ToString(op,opright,opleft);:}
        |EXP:op punto tolower pari pard {:RESULT = new ToLower(op,opright,opleft);:}
        |EXP:op punto id:atrib {:RESULT = new Acceso(op,atrib, opright,opleft);:}
        |EXP:op punto touper pari pard {:RESULT = new ToUper(op,opright,opleft);:}
        |pari:t PRIMITIVO:tipo pard EXP:op {:RESULT = new Casteo(op,tipo, tright, tleft);:} 
        |pari:t id:tipo pard EXP:op {:RESULT = new Casteo(op,tipo, tright, tleft);:}
        |entero:v {: RESULT = new Literal(new Tipo(Tipo.TypePrimitive.INT), v, vright,vleft);:}
        |decimal:v {: RESULT = new Literal(new Tipo(Tipo.TypePrimitive.DOUBLE), v, vright,vleft);:}
        |booleano:v {: RESULT = new Literal(new Tipo(Tipo.TypePrimitive.BOOL), v, vright,vleft);:}
        |cadena:v {: RESULT = new Literal(new Tipo(Tipo.TypePrimitive.STRING), v, vright,vleft);:}
        |caracter:v {: RESULT = new Literal(new Tipo(Tipo.TypePrimitive.CHAR), v, vright,vleft);:}
        |id:v {: RESULT = new Variable(v, vright,vleft);:}
        |nuevo:n PRIMITIVO:tipo LEXP:l {: RESULT = new ExpresionArreglo(tipo,l,nright,nleft);:}
        |nuevo:n id:tipo LEXP:l {: RESULT = new ExpresionArreglo(new Tipo(tipo), l,nright,nleft);:}
        |pari EXP:op pard {: RESULT = op;:}
        |EXP:id LEXP:coor {: RESULT = new AccesoVector(id, coor , idright, idleft);:}   
        |EXPLICITCAST:exp {:RESULT = exp;:}
;


RETORNO ::= retorno:r EXPRETORNO:exp puntocoma{:RESULT = new Retorno(exp, rright, rleft);:} 
;

EXPRETORNO::= 
            EXP:exp {:RESULT = exp;:}
          | nulo:r {:RESULT = new Literal(new Tipo(Tipo.TypePrimitive.NULO), null, rright, rleft);:}
;


/*Declaracion de métodos*/
FUNCION::= CABECERAMET:funcion BLOQUE:bloque {: funcion.setInstrucciones(bloque); RESULT = funcion;:}
            | CABECERAMET:funcion puntocoma {:RESULT = funcion;:}
;

CABECERAMET::= 
        LMODFICADOR:m RESULTADO:res id:nombre pari LPARFORMAL:lf pard {: Funcion f = new Funcion(m,res,nombre, lf, mright,mleft ); RESULT = f;:}
      | RESULTADO:res id:nombre pari LPARFORMAL:lf pard {: Funcion f = new Funcion( new ArrayList<String>(),res,nombre, lf, resright,resleft ); RESULT = f;:}

;



LPARFORMAL::= 
         LPARFORMAL:lista coma PARFORMAL:par {:lista.add(par); RESULT = lista;:}
        |PARFORMAL:par {:ArrayList<ParametroFormal> l = new ArrayList<ParametroFormal>(); l.add(par); RESULT = l;:}
        |{:ArrayList<ParametroFormal> l = new ArrayList<ParametroFormal>();RESULT = l;:}
;


PARFORMAL::=  
         TIPO:tipo id:nombre{: RESULT = new ParametroFormal(tipo, nombre, true,0, tiporight, tipoleft);:}
        | final_:f TIPO:tipo id:nombre {: RESULT = new ParametroFormal(tipo, nombre, true,0,fright, fleft);:}
        | TIPO:tipo id:nombre NDIM:n{: RESULT = new ParametroFormal(tipo, nombre, true,n, tiporight, tipoleft);:}
        | final_:f TIPO:tipo id:nombre NDIM:n {: RESULT = new ParametroFormal(tipo, nombre, true, n, fright, fleft);:}        
;

RESULTADO::= TIPO:t {:  RESULT = t;:}
            |tvoid:t {:  RESULT = new Tipo(t);:}
;


LMODFICADOR ::= 
              LMODFICADOR:l MODIFICADOR:m {: l.add(m); RESULT = l; :}
            | MODIFICADOR:m {: ArrayList<String> l = new ArrayList<String>() ; if(m!=null){l.add(m);} RESULT = l;:}
;

MODIFICADOR::= publico:m {:RESULT = m;:}
            |  protegido:m {:RESULT = m;:}
            |  privado:m {:RESULT = m;:}
            |  abstracto:m {:RESULT = m;:}
            |  final_:m {:RESULT = m;:}
            |  estatico:m {:  RESULT = m;:}
            
;

/*Fin declaración de métodos*/


LEXP::= LEXP:l corchetei EXP:exp corcheted{:l.add(exp); RESULT = l;:}
        | corchetei EXP:exp corcheted {: ArrayList<Expresion> l = new ArrayList<Expresion>(); l.add(exp); RESULT = l;:}
;

ARR::= llavei LITEM:nodo llaved {: RESULT = nodo;:}
;

LITEM::= LITEM:nodo coma ITEM:item {: nodo.addHijo(item); RESULT = nodo; :}
        |ITEM:item  {: NodoNario nodo = new NodoNario(); nodo.addHijo(item); RESULT = nodo;:}
;

ITEM::= EXP:exp {: RESULT = new NodoNario(exp);:} 
        |ARR:exp {: RESULT = exp;:} 
;

AUMENTO::= EXP:op aumento {:RESULT = new Aumento(op, opright, opleft);:}
          |aumento EXP:op {:RESULT = new Preaumento(op, opright, opleft);:}       
            ;
DECREMENTO::= EXP:op decremento {:RESULT = new Decremento(op, opright, opleft);:}
              |decremento EXP:op {:RESULT = new Predecremento(op, opright, opleft);:}
;

TER::= EXP:c interrogante EXP:v dospuntos EXP:f{:RESULT = new Ternario(c,v,f,cright,cleft);:}
;

PRIMITIVO ::=   tint:t {:RESULT = new Tipo(Tipo.TypePrimitive.INT,tright, tleft);:}
		|tchar:t {:RESULT =  new Tipo(Tipo.TypePrimitive.CHAR,tright, tleft);:}
        |tdouble:t {:RESULT = new Tipo(Tipo.TypePrimitive.DOUBLE,tright, tleft);:}
		|tbool:t {:RESULT = new Tipo(Tipo.TypePrimitive.BOOL,tright, tleft);:}
		|tstring:t {:RESULT = new Tipo(Tipo.TypePrimitive.STRING,tright, tleft);:}		
		;
